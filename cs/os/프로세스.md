# Process(프로세스)

&nbsp;

# 1. 들어가며

지난번에 실제로 메모리에 적재돼서 실행되는 프로그램을 **프로세스**라 한다고 공부한 바 있습니다. 이번 글에서는 프로세스에 대해서 조금 더 자세히 알아보도록 하겠습니다.

&nbsp;

# 2. Process(프로세스) 개요

지난 시간에 정리한 것처럼 프로세스는 메모리에 적재돼서 현재 실행 중인 프로그램을 의미합니다. 프로세스를 크게 분류해보면 두 가지로 나눌 수 있습니다.

1. foreground process: 사용자가 실제로 볼 수 있는 프로세스 ex) 웹 브라우저, 메모장
2. background process: 사용자가 볼 수 없는 프로세스 ex) 데몬

&nbsp;

컴퓨터에서 모든 실행의 주체는 CPU 입니다. 그런데 CPU는 물리적 하드웨어이기 때문에 컴퓨터에 따라 한정적입니다. 따라서 수많은 프로세스들은 순차적으로 자신에게 할당된 시간만큼 CPU를 이용하고 자신의 차례가 끝나면 순서를 다음 프로세스에 넘겨주는 식으로 프로세스들은 실행이 됩니다. 이렇게 차례가 바뀌면서 실행되는 과정이 굉장히 빠르게 일어나기 때문에 사용자는 프로세스들이 동시에 실행된다고 느낄 수 있는 것입니다.

그렇다면 CPU는 어떤 기준을 가지고 프로세스들이 이렇게 빠르게 번갈아 수행되게끔 관리하는 것일까요? 이 때 등장하는 것이 **Process 제어 블록 (PCB)** 입니다. 

&nbsp;

# 3. Process 제어 블록(PCB)이란 무엇인가?

PCB를 간단하게 정의해보자면 다음과 같습니다.

> 한정된 CPU를 수많은 프로세스들이 빠르게 번갈아 수행되게끔 관리하기 위해 사용하는 자료구조

PCB는 자료구조입니다. 자료구조라 함은 자료를 저장하는 다양한 방식인데요. 이를 통해 PCB 역시 특정 자료를 저장하는 역할을 수행한다는 것을 유추할 수 있습니다. 

운영체제는 PCB에 저장된 자료를 참고하여 프로세스를 관리합니다. PCB는 프로세스 생성 시 **커널 영역**에 생성이 되고 프로세스가 종료되면 같이 폐기됩니다. 

&nbsp;

PCB에는 다양한 자료들이 저장되는데 대표적으로 다음과 같은 것들이 있습니다. (운영체제마다 약간의 차이가 있을 수 있습니다.)

1. PID
2. 레지스터 값
3. CPU 스케줄링 정보
4. 메모리 정보
5. 프로세스 상태

이제 각각의 자료들이 어떤 것을 의미하는지에 대해 살펴보도록 하겠습니다.

## 3.1 PID

PID는 Process ID의 약자입니다. 프로세스를 식별하기 위한 고유한 ID 번호입니다. 모든 프로세스는 생성 시 각각 고유한 PID를 부여받게 됩니다. 학생의 학번과 유사합니다.

## 3.2 레지스터 값

앞서 한정적인 CPU의 자원을 사용하기 위해 프로세스들은 자신의 차례가 왔을 때만 실행되고 자신에게 할당된 시간이 끝나게 되면 다음 프로세스에게 차례를 넘겨준다고 했는데요. 만약 이렇게 프로세스가 실행 중이다가 갑자기 다음 프로세스로 차례가 넘어가게 되면 실행 중이던 프로세스의 정보들은 어떻게 되는 것일까요? 초기화 되는 것일까요?

PCB에 저장된 레지스터 값은 이런 문제를 극복하게 도와줍니다. 레지스터 값은 어떤 값들이 저장되는지 보다 왜 레지스터 값이 저장이 되는지를 이해하는 것이 더 중요합니다. 프로세스들은 자신의 차례가 왔을 때 이전까지 사용한 레지스터 중간값을 모두 복원하고 실행을 재개합니다. 이렇게 하기 때문에 프로세스들이 여러 번 차례가 바뀌면서 실행이 되더라도 사용자가 느끼기에는 프로세스가 다시 처음부터 실행되는 것이 아니라 연속적으로 중단없이 실행될 수 있는 것입니다. 

저장되는 레지스터 값의 예로는 Program 카운터, 스택 포인터 등이 있습니다. 

## 3.3 CPU 스케줄링 정보

CPU 스케줄링 정보는 프로세스가 언제, 어떤 순서로 CPU를 할당 받을지에 대한 정보입니다.

## 3.4 메모리 정보

프로세스가 어느 주소에 저장되었는지에 대한 정보입니다.

## 3.5 프로세스 상태

프로세스 상태에 관해서는 밑에서 조금 더 자세히 정리해보도록 하겠습니다.

&nbsp;

# 4. Context Switch(문맥 교환)

프로세스는 계속해서 차례를 바꿔가면서 실행이 되기 때문에 실행 도중에 차례가 바뀌게 될 수도 있습니다. 다시 자기 차례가 왔을 때 실행을 원활하게 재개하기 위한 정보를 **Context(문맥)** 라고 합니다. 따라서 Context를 잘 백업해두면 해당 프로세스를 언제든 재개하는 것이 가능합니다. 

새로운 프로세스 실행 시 기존 실행 중이던 프로세스의 문맥을 백업하고 새로 시작되는 프로세스의 문맥을 복구하는 과정을 **Context Switch**라고 합니다. 이것을 도식화 하면 다음과 같습니다.

<img width="600" alt="도식1" src="https://github.com/hyunzxn/TIL/assets/100478841/adca4343-9d59-4efb-a6b1-3c161018bfaf">

&nbsp;

프로세스가 이렇게 Context Switch가 발생할 때 메모리의 사용자 영역에서는 어떤 일이 발생하고 있을까요? 사용자 영역에서는 영역을 나누어 저장이 됩니다. 영역에는 여러 가지가 있는데 대표적으로 4가지가 있습니다.

1. 코드 영역(텍스트 영역)
2. 데이터 영역
3. 힙 영역
4. 스택 영역

&nbsp;

## 4.1 코드 영역(텍스트 영역)

실행할 수 있는 코드, 기계어로 이루어진 명령어가 저장되는 영역입니다. 여기에 저장되는 명령어들은 CPU가 실행할 명령어들입니다. 따라서 변경될 일이 적습니다. 그래서 코드 영역은 보통 수정이 불가능한 read-only 영역이 됩니다. 

## 4.2 데이터 영역

프로그램이 실행되는 동안 유지할 데이터를 저장하는 영역입니다. 대표적인 예로는 전역변수가 있습니다. 

## 4.3 힙 영역

개발자가 직접 메모리를 할당할 수 있는 영역입니다. 여기서 중요한 것은 메모리를 할당했으니 다 사용하고나서는 비워주는 것이 필요합니다. 충분히 비워주지 않으면 나중에 메모리가 부족하다는 에러가 발생할 수 있습니다.

이렇게 메모리를 비워주는 것을 프로그래밍 언어 차원에서 지원을 해주는 경우가 있는데 대표적으로 Java의 **Garbage Collection**이 있습니다.

## 4.4 스택 영역

데이터가 일시적으로 저장되는 영역입니다. 대표적인 예로는 매개변수, 지역 변수가 있습니다. 

코드 영역과 데이터 영역을 묶어서 정적 할당 영역, 힙 영역과 스택 영역을 묶어서 동적 할당 영역이라고 분류하기도 합니다.

&nbsp;

# 5. Process 상태

앞서 PCB에 저장되는 다양한 프로세스 정보 중 Process 상태가 있다고 언급한 바 있습니다. 프로세스 상태는 운영체제마다 차이가 있긴 하지만 대표적으로 5가지로 구분할 수 있습니다.

1. 생성 상태
2. 준비 상태
3. 실행 상태
4. 대기 상태
5. 종료 상태

이제 하나하나 알아보도록 하겠습니다.

&nbsp;

## 5.1 생성 상태

프로세스가 메모리에 적재되고 PCB에 프로세스의 정보가 할당되는 상태입니다.

## 5.2 준비 상태

프로세스가 CPU를 할당 받기는 했으나 자신의 차례가 아니어서 기다리고 있는 상태입니다.

## 5.3 실행 상태

프로세스가 CPU를 할당받아서 실행이 되고 있는 상태입니다. 자신에게 할당된 시간이 모두 끝나면 다시 준비 상태가 됩니다. 이 때 만약 입출력장치를 사용하여 입출력작업을 하게 되는 경우에는 대기 상태가 됩니다.

## 5.4 대기 상태

실행 상태에서 입출력작업을 하는 경우를 의미합니다. 입출력작업이 모두 끝나면 다시 준비 상태가 됩니다.

## 5.5 종료 상태

프로세스가 완전히 종료되고 PCB 와 메모리가 모두 정리된 상태입니다.

&nbsp;

이상의 5가지 상태를 도식화 하면 다음과 같습니다.

<img width="791" alt="도식2" src="https://github.com/hyunzxn/TIL/assets/100478841/a67f4bd1-cda9-43e5-a033-ebb4680306f2">

&nbsp;

# 6. 프로세스 계층 구조

Window 운영체제를 제외한 다른 운영체제에서는 프로세스들이 계층 구조를 가질 수 있습니다. 이 말을 좀 더 풀어서 설명을 해보자면 **특정 프로세스는 실행 중 시스템 호출을 통해 다른 프로세스를 생성하는 것이 가능하다는 뜻입니다.**

예를 들어 프로세스 A가 실행 중인데 또 다른 프로세스 B를 생성하게 되면 이 때 프로세스 A는 부모 프로세스가 되고 프로세스 B는 자식 프로세스가 됩니다. 그리고 만약 또 프로세스 B가 다른 프로세스 C를 생성하면 프로세스 B는 또 부모 프로세스가 되고 프로세스 C는 자식 프로세스가 됩니다. 즉 프로세서는 계속해서 계층 구조를 확장할 수 있습니다.

그렇지만 부모 프로세스 A와 자식 프로세스 B는 별도의 프로세스이기 때문에 별개의 PID를 가지게 됩니다. 운영체제에 따라 프로세스 정보 중 **PPID**라는 것을 보여주는 경우가 있는데요. 이 때 PPID 가 Parent PID 입니다. 

그렇다면 이렇게 실행 중인 프로세스가 자신의 자식 프로세스를 실행하는 기법이 어떤 것일까요?

## 6.1 프로세스 생성 기법

부모 프로세스 A, 자식 프로세스 B라고 가정을 해보겠습니다. 

- 프로세스 A는 **fork 시스템 호출**을 통해 자신의 복사본을 생성하고 이 때 이 복사본이 자식 프로세스 B가 됩니다. 
- 프로세스 B는 **exec 시스템 호출**을 통해 자신의 메모리 공간을 다른 프로그램으로 교체 → 덮어쓰기 느낌

&nbsp;

부모 프로세스는 우선 자신의 복사본에 해당하는 프로세스를 만듭니다. 물론 별도의 프로세스이기 때문에 PID와 메모리 주소 등은 다릅니다. 그런데 이렇게 하면 동일한 프로세스 2개가 병행 실행 되는 것에 불과합니다. 복사본 상태인 자식 프로세스는 exec 시스템 호출을 통해 새로운 프로그램을 자신 위에 덮어씌웁니다. 이렇게 하면 비로소 이제 서로 다른 두 개의 프로세스가 실행이 되게 되는 것입니다. 

&nbsp;

# 7. 마치며

오늘은 프로세스에 대해서 정리해봤습니다. 오늘 정리한 내용 중에서는 Context Switch 개념이 제일 중요할 것 같습니다. 프로세스는 스레드와 함께 운영체제에서 제일 비중있게 다뤄지는 개념인 것 같습니다. 지금 정리한 것 외에도 조금 더 추가적인 공부를 하면 좋을 것 같다는 생각이 들기도 합니다.
