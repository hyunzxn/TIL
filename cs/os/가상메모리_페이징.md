# 가상 메모리_페이징

&nbsp;

# 1. 들어가며

이번 글에서는 프로세스와 메모리의 관계에 대해서 다뤄보고자 합니다. 메모리에 적재돼서 실행되는 프로그램을 프로세스라 하는데요. 그렇기 때문에 프로세스의 크기와 메모리의 크기는 원활한 프로세스의 실행과 효율적인 메모리 사용을 위해 중요한 요소입니다. 이번 글에서는 효율적인 메모리 사용을 위해 운영체제가 하는 일 중에 하나인 가상 메모리를 사용한 페이징 기법에 대해서 정리해보고자 합니다.

&nbsp;

# 2. 메모리 할당

가상 메모리에 관해서 알기 이전에 프로세스가 메모리에 어떻게 할당 되는지를 우선 알아보고자 합니다. 엄밀히 말하면 연속 메모리 할당 방식에 대해서 정리해보고자 하는데요. 이 방식이 어떤 문제점이 있는지 그리고 이 방식의 한계를 극복하기 위해 가상 메모리가 나왔다는 것을 염두에 두고 보면 좋을 것 같습니다.

&nbsp;

예시를 먼저 들면서 설명을 이어 가보겠습니다. 

<img width="770" alt="도식1" src="https://github.com/hyunzxn/TIL/assets/100478841/1cb05b1b-d999-4599-be62-6939a46b4d2d">

이런 상황일 때 적재할 프로세스를 세 곳의 빈 공간 중 어디에 적재를 해야할까요? 연속 메모리 할당 방식에는 3가지가 있습니다. 

1. 최초 적합: 메모리 내의 빈 공간을 순서대로 검색하다가 적재할 수 있는 공간을 발견하면 바로 그 공간에 프로세스를 적재하는 방식
2. 최적 적합: 메모리 내의 빈 공간을 모두 검색하고 적재 가능한 가장 작은 공간에 할당하는 방식
3. 최악 적합: 메모리 내의 빈 공간을 모두 검색하고 적재 가능한 가장 큰 공간에 할당하는 방식

&nbsp;

그런데 이런 연속 메모리 할당 방식에는 치명적인 문제점이 있습니다. 바로 **외부 단편화** 현상입니다. 

&nbsp;

## 2.1 외부 단편화

그렇다면 외부 단편화 문제는 무엇일까요? 예시를 들어보겠습니다.

> 사용자 영역 메모리 크기: 200MB
>
> - 프로세스 A: 50MB
> - 프로세스 B: 30MB
> - 프로세스 C: 100MB
> - 프로세스 D: 20MB

&nbsp;

이런 상황에서 이제 프로세스들을 메모리에 적재해보겠습니다. 그러면 지금 사용자 영역 메모리 크기와 프로세스들의 크기를 모두 더한 값이 같기 때문에 차례대로 쭈욱 적재하면 될 것 같습니다.

이제 이런 상황에서 프로세스 B, D가 완료됐다고 해보겠습니다. 그러면 프로세스 B, D가 적재되어 있던 공간은 빈 공간이 됩니다. 그리고 이제 50MB 크기의 새로운 프로세스 E가 적재될 메모리 공간을 기다리고 있습니다. 프로세스 B, D가 있던 공간이 빈 공간이 되면서 메모리에는 지금 50MB의 여유 공간이 있지만 프로세스 E는 메모리에 적재될 수 없습니다. 메모리가 한 번에 50MB의 프로세스를 담을 수 없기 때문입니다. 자연스럽게 50MB 메모리는 아무런 일도 하지 않는 낭비 자원이 되고 맙니다.

정리해보자면 외부 단편화 현상은 프로세스를 할당하기 어려울 정도로 작은 메모리 공간이 계속해서 생겨나면서 메모리가 낭비되는 현상이라고 할 수 있습니다.

그렇다면 외부 단편화 현상을 해결하기 위한 방법은 무엇이 있을까요?

1. Memory 압축: 흩어져 있는 빈 공간들을 하나로 모으는 방식입니다. (요즘 운영체제에서는 대중적이지 않습니다.)
2. 가상 메모리를 이용한 페이징 기법: 오늘날 대다수의 운영체제에서 사용하는 대중적인 방식입니다.

&nbsp;

지금까지 가상 메모리를 이용한 페이징 기법이 왜 필요한 지에 대해서 알아봤습니다. 이제 가상 메모리와 페이징에 대해서 정리해보겠습니다.

&nbsp;

# 3. 가상 메모리

그렇다면 가상 메모리란 무엇일까요? 가상 메모리에 대한 정의를 해보면 다음과 같습니다.

> 실행하고자 하는 프로그램의 일부만 메모리에 적재하여 실제 메모리 크기보다 더 큰 프로세스를 실행할 수 있도록 하는 기술

&nbsp;

이러한 가상 메모리를 이용한 기법 중에는 페이징과 세그멘테이션이 있는데 좀 더 대중적인 방식인 페이징에 대해서만 정리해보도록 하겠습니다. 

&nbsp;

## 3.1 페이징

가상 메모리를 활용한 페이징이 등장한 이유는 외부 단편화 현상때문이라고 앞서 정리한 바 있습니다. 그렇다면 외부 단편화 현상의 가장 근본적인 문제점은 무엇일까요? 그건 바로 각기 다른 크기의 프로세스들이 연속적으로 메모리에 할당되었기 때문입니다. 이것을 역으로 생각하면 외부 단편화 현상을 막을 수 있지 않을까요? 페이징은 이런 아이디어처럼 **프로세스를 일정한 크기로 자르고 이를 메모리에 비연속적으로 할당**을 하는 기법입니다. 그렇다면 이걸 어떻게 구현할까요?

페이징을 구현할 때는 **페이지**와 **프레임**이라는 개념이 등장합니다. 프로세스의 논리 주소 공간을 페이지라는 일정 단위로 자르고 메모리의 물리 주소 공간을 프레임이라는 페이지와 동일한 단위로 나눈 다음에 페이지를 프레임에 할당하는 방식으로 페이징이 이뤄집니다.

그런데 이렇게 하면 한 가지 의문점이 듭니다. CPU 입장에선 메모리에 올라와 있는 프로세스를 보고 실행을 시키는데 프로세스들이 조각조각나서 떨어져 있게 되는 것입니다. 이것을 도와주기 위해 **페이지 테이블**이라는 것이 있습니다.

&nbsp;

## 3.2 페이지 테이블

페이지 테이블은 프로세스가 실제 메모리 내의 주소인 물리주소에는 비연속적으로 배치되어 있더라도 CPU가 바라보는 논리주소에는 연속적으로 배치되게 하는 방법입니다. 즉 페이지 번호와 프레임 번호를 매칭 시켜주는 테이블입니다. 

페이지 테이블은 프로세스마다 가지고 있고 메모리에 저장됩니다. 그림으로 표현하면 다음과 같습니다.

![IMG_0151](https://github.com/hyunzxn/TIL/assets/100478841/7ddfce2d-300e-41e7-b19f-70c7086f88b4)

&nbsp;

**참고**

> 그런데 페이징 역시 만능은 아닙니다. 외부 단편화를 해결하기 위해 등장한 페이징은 **내부 단편화**라는 문제점을 발생시킵니다. 예를 들어보겠습니다.
>
> 만약 페이지 크기가 10KB 이고 프로세스 크기가 108KB 라면? 2KB의 내부 단편화가 생깁니다. 108KB의 프로세스를 담으려면 10개의 페이지가 필요한데 그러면 페이지의 총 크기는 110KB가 됩니다. 따라서 2KB가 비게 되는 것입니다.
>
> 그렇지만 내부 단편화는 외부 단편화에 비해 메모리 크기가 작다는 차이점은 있습니다.

&nbsp;

모든 프로세스는 페이지 테이블을 가진다고 했는데요. 그렇다면 페이지 테이블은 어디에 저장이 되는 것일까요? 그리고 CPU가 페이지 테이블을 보기 위해선 CPU가 페이지 테이블이 어디에 저장이 되어있는지를 알아야 할 것입니다. 이렇듯 각각의 페이지 테이블이 어디에 저장 돼 있는지를 나타내기 위한 특별한 레지스터가 있는데 그것이 바로 **프로세스 테이블 베이스 레지스터(PTBR)** 입니다. PTBR는 각 프로세스의 페이지 테이블이 적재되어 있는 주소를 담고 있다고 생각면 될 것 같습니다. 

그런데 페이지 테이블이 메모리에 적재되는 것에 한 번 생각해볼 필요가 있습니다. 페이지 테이블이 메모리에 저장돼 있는 것이 마냥 좋은 것은 아닙니다. 왜냐하면 CPU가 프로세스를 실행시키기 위해 프로세스에 접근할 때 메모리에 두 번 접근해야되기 때문입니다. 페이지 테이블을 참조하기 위해 한 번, 그리고 페이지를 참조하기 위해서 한 번 총 두 번 접근하게 되는 것입니다. 이런 문제를 극복하기 위해 사용하는 것이 **TLB**입니다.

TLB는 페이지 테이블의 일부의 캐시 메모리에 해당된다고 이해하면 좋을 것 같습니다. CPU는 메모리에 두 번 접근할 필요 없이 TLB에 접근해서 페이지 번호를 알고 메모리에는 한 번만 접근할 수 있게 되는 것입니다.

&nbsp;

## 3.3 페이징에서의 주소 변환

페이징을 사용하는 시스템에서 특정 주소에 접근하고자 한다면 어떤 정보가 필요할까요? 두 가지 정도가 있습니다.

1. 어떤 페이지/프레임에 접근하고 싶은가?
2. 접근하려는 주소가 그 페이지 혹은 프레임으로부터 얼마나 떨어져 있는가?

이것을 위해서 페이징 시스템에서의 논리주소는 두 가지로 구성되어 있습니다.

> 페이지 번호 + 변위(offset)

그리고 이러한 논리주소는 페이지 테이블을 통해 물리 주소(프레임 번호 + 변위)로 변환됩니다. 그렇다면 논리 주소에서의 변위와 물리 주소에서의 변위는 같을까요, 다를까요? 정답은 같다 입니다. 왜냐하면 페이지의 크기와 프레임의 크기가 같기 때문에 떨어진 거리에 해당되는 변위는 같을 수 밖에 없는 것입니다.

&nbsp;

## 3.4 페이지 테이블 엔트리

페이지 테이블 엔트리란 페이지 테이블이 담는 정보를 의미합니다. 페이지 번호, 프레임 번호 외에도 많은 정보들이 담길 수 있는데요, 각 운영체제마다 차이가 있습니다. 몇 가지 대표적인 페이지 테이블 엔트리를 살펴보도록 하겠습니다.

1. 유효 비트: 현재 해당 페이지에 접근 가능 여부 → 유효 비트가 1이라면 페이지가 메모리에 적재 되어 있다는 뜻이고 0이라면 그렇지 않다라는 뜻입니다. 만약 유효 비트가 0인 페이지에 접근하려고 한다면 **페이지 폴트**라는 인터럽트가 발생합니다.

   

2. 보호 비트: 페이지 보호 기능 표시 → 보호 비트가 1이라면 읽기와 쓰기가 모두 가능하고 0이라면 읽기 전용이라는 뜻입니다. 리눅스에서 프로세스를 볼 때 `rwx` 가 있고 100, 010 이런 것을 본 적이 있을텐데요, 네 이 때 말하는 1, 0 이 보호 비트입니다. r은 읽기, w는 쓰기, x는 실행 권한을 의미합니다.

   

3. 참조 비트: CPU가 이 페이지 접근한 적이 있는지 여부 → 참조 비트가 1이라면 접근한 적이 있는 것이고 0이라면 접근한 적이 없는 페이지를 의미합니다. 

   

4. 수정 비트: CPU가 이 페이지에 데이터를 쓴 적이 있는지 여부 → 수정 비트가 1이라면 수정된 적이 있는 것이고 0이라면 수정된 적이 없는 페이지를 의미합니다. 수정 비트의 존재 이유가 따로 있습니다. 스왑핑과 관련이 있는데요, 이 페이지가 메모리에서 사라질 때 보조기억장치에 쓰기 작업을 할 필요가 있는지 없는지를 판단하기 위해 존재하는 것입니다. 만약 어떤 페이지가 수정된 적이 한 번도 없다면 보조기억장치로 스왑핑 될 때 보조기억장치에서는 쓰기 작업을 할 필요가 없습니다. 그런데 만약 페이지가 메모리에서 수정된 적이 있다면 보조기억장치에서도 동기화를 위해서 쓰기 작업을 해야만 합니다. 이런 것을 판단하는 기준이 수정 비트가 되는 것입니다.

&nbsp;

# 4. 마치며

이번 글에서는 되게 다양한 개념에 대해서 배웠습니다. 페이징은 굉장히 중요한 내용이니 확실히 복습을 해두고 개념을 익히는게 중요할 것 같습니다. 

