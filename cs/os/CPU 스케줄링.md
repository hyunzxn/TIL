# CPU 스케줄링

&nbsp;

# 1. 들어가며

컴퓨터에서 명령을 처리하는 자원은 CPU입니다. 프로세스 역시 CPU의 실행을 통하여 실행될 수 있는데요. 운영체제가 CPU를 관리하여 프로세스를 실행하는 것을 CPU 스케줄링이라 합니다. 이번 글에서는 CPU 스케줄링에 대해서 정리해보도록 하겠습니다.

&nbsp;

# 2. CPU 스케줄링이란?

CPU 스케줄링이란 운영체제가 CPU를 관리하는 방법입니다. 좀 더 자세히 풀어서 설명해보면 **프로세스들에게 공정하고 합리적으로 CPU 자원을 배분**하는 것을 의미합니다. 그렇다면 "공정하고 합리적"의 기준은 어떻게 될까요?

이 때 기준은 **우선순위**가 됩니다. 우선순위는 프로세스가 생성되면 PCB에 저장이 되는 정보 중 하나입니다. 다만 이 우선순위는 중요도로 결정되는 것이 아닙니다. 예를 들어 입출력작업이 많은 프로세스와 CPU 작업이 많은 프로세스 중 우선순위가 더 높은 것은 무엇일까요? 이 경우에는 입출력작업이 많은 프로세스가 우선순위가 더 높습니다. 왜냐하면 프로세스는 입출력작업 시 대기 상태가 되기 때문에 CPU를 사용하지 않습니다. 따라서 운영체제 입장에서는 입출력작업이 많은 프로세스를 우선적으로 해치워버리고 CPU 사용이 많은 프로세스를 처리하는 것이 유리하기 때문입니다. 

그렇다면 운영체제는 어떻게 CPU를 스케줄링 할까요? 이것을 알기 위해서는 우선 **스케줄링 큐**라는 개념을 알아야 합니다.

&nbsp;

## 2.1 스케줄링 큐(Queue)

그렇다면 스케줄링 큐라는 것은 무엇일까요? Queue는 사전적인 의미로 대기줄을 의미하는데요. 스케줄링 큐도 동일합니다. CPU를 사용하고 싶어하는 프로세스들을 줄을 세우는 것이 바로 스케줄링 큐입니다. 줄을 세울 때는 보통 사용하려는 자원에 맞춰서 줄을 세우게 됩니다. 이를 도식화 하면 다음과 같습니다.

<img width="800" alt="도식1" src="https://github.com/hyunzxn/TIL/assets/100478841/1c8a44e5-159e-47e7-bd4b-06f425a591d5">

여기서 주의해야 될 것이 하나 있습니다. 일반적인 자료 구조에서의 Queue는 선입선출 방식이 원칙입니다. 먼저 들어온 자료가 먼저 나가게 되는 First In First Out(FIFO) 방식인 것이죠. 그렇지만 스케줄링 큐에서는 무조건 FIFO 방식으로 프로세스가 처리되지 않습니다. 

스케줄링 큐에는 두 가지 종류가 있습니다. 

1. 준비 큐: CPU를 이용하려는 프로세스들이 대기하는 큐입니다.
2. 대기 큐: 입출력 장치를 이용하려는 프로세스들이 대기하는 큐입니다. 대기 큐는 보통 입출력 장치별로 있는 경우가 많습니다.

&nbsp;

프로세스의 상태와 준비 큐, 대기 큐를 같이 합쳐서 도식화 하면 아래 그림처럼 됩니다. 

<img width="950" alt="도식2" src="https://github.com/hyunzxn/TIL/assets/100478841/ee092e11-96e4-4001-b181-7c896f59f59d">

&nbsp;

## 2.2 스케줄링 방식의 분류

스케줄링이란 것이 이제 어떤 것인지 알게 됐습니다. 이런 스케줄링을 하는 방식은 두 가지가 있습니다.

1. 선점형
2. 비선점형

선점형과 비선점형을 이해하기 위해서 한 가지 상황을 가정하겠습니다. 

> 프로세스 A가 CPU를 이용하여 실행 중입니다. 그런데 프로세스 B가 지금 자기가 급하다며 CPU를 사용하게 해달라고 하고 있는 상황!

이런 상황에서 선점형과 비선점형이 어떤 차이점을 보이는지 살펴보고자 합니다. 우선 선점형은 CPU 자원을 빌려줍니다. 반면에 비선점형은 CPU 자원을 절대로 빌려주지 않습니다. 각각의 장단점을 보면 다음과 같습니다.

**선점형**

장점: 특정 프로세스의 CPU 자원 독점 방지, 자원을 골고루 배분할 수 있다.

단점: Context-Switching이 자주 발생하여 오버헤드가 발생할 수 있다.



**비선점형**

선점형의 반대라고 생각하면 좋을 것 같습니다.

&nbsp;

이제 CPU 스케줄링이 어떤 것인지 알았고 스케줄링 큐에 대해서도 알게 됐습니다. 그러면 이제 본격적으로 운영체제가 CPU를 스케줄링하는 대표적인 알고리즘에 대해서 정리해보도록 하겠습니다.

&nbsp;

# 3. CPU 스케줄링 알고리즘

CPU 스케줄링 알고리즘에는 여러 가지가 있는데요, 이번 글에서는 대표적인 7가지를 정리해보도록 하겠습니다. 우선 소개를 하면 다음과 같습니다.

1. 선입선처리 스케줄링
2. 최단작업 우선 스케줄링
3. 라운드 로빈 스케줄링
4. 최소 잔여시간 스케줄링
5. 우선순위 스케줄링
6. 다단계 큐 스케줄링
7. 다단계 피드백 큐 스케줄링

&nbsp;

## 3.1 선입선처리 스케줄링

>  First Come First Served 스케줄링 (FCFS)

가장 단순한 방식의 스케줄링입니다. 준비 큐에 프로세스가 삽입된 순서대로 처리하는 비선점 방식입니다. 따라서 하나의 프로세스가 끝나기 전에는 다른 프로세스는 CPU 자원을 사용할 수 없습니다. 먼저 CPU를 요청한 프로세스부터 CPU를 할당하는 직관적인 방식입니다. 

이 방식의 단점은 후순위로 요청한 프로세스들의 대기 시간이 길어질 수 있다는 것입니다. 예를 들어 프로세스 A가 1순위로 CPU를 요청했고 처리 시간이 10초입니다. A 다음에 요청한 프로세스 B는 처리 시간이 2초입니다. 그렇지만 프로세스 B가 처리되려면 총 12초의 시간이 필요합니다. 프로세스 A가 처리하는데 걸리는 시간을 대기해야되기 때문입니다. 

이런 현상을 **호위효과**라고 합니다.

## 3.2 최단작업 우선 스케줄링

>  Shortest Job First

호위효과를 방지하기 위해서 CPU 실행시간이 짧은 프로세스부터 먼저 실행하는 방식입니다.

## 3.3 라운드 로빈 스케줄링

선입선처리 방식 + **타임 슬라이스**로 이루어진 스케줄링 방식입니다. 타임 슬라이스란 각 프로세스가 CPU를 사용할 수 있는 정해진 시간을 의미합니다. 이 때 만약 프로세스가 타임 슬라이스 안에 완료되지 않는다면 큐의 맨 뒤로 삽입되게 됩니다. 

라운드 로빈 스케줄링에서는 타임 슬라이스의 크기가 중요합니다. 크기가 너무 작으면 Context-Switching이 빈번하게 발생하여 오버헤드의 위험이 있고, 너무 크면 선입선처리 스케줄링 방식과 차이가 없게 되기 때문입니다.

## 3.4 최소잔여시간 우선 스케줄링

> Shortest Remaining Time

최단작업우선 스케줄링과 라운드 로빈 스케줄링이 혼합된 방식입니다. 정해진 시간만큼 CPU를 이용하되 다음으로 CPU를 사용할 프로세스를 선정하는 기준이 프로세스의 남은 잔여 시간이 됩니다.

## 3.5 우선순위 스케줄링

프로세스에 우선순위를 부여하고 우선순위가 높은 프로세스부터 실행하는 방식입니다. 만약 우선순위가 같다면 선입선처리 스케줄링 방식으로 처리합니다. 

우선순위 스케줄링 방식에는 근원적인 문제점이 하나 있습니다. 바로 **기아(starvation)** 현상입니다. 이것은 우선순위가 높은 프로세스만 계속 실행을 하다보면 우선순위가 낮은 프로세스는 준비 큐에 먼저 삽입되었더라도 실행이 계속 연기된다는 것입니다.

이것을 해결하기 위한 방법으로는 **에이징**이 있습니다. 오랫동안 대기한 프로세스의 우선순위를 시간이 지남에 따라 점차 높이는 방식입니다. 

## 3.6 다단계 큐 스케줄링

우선순위 큐 스케줄링의 발전된 형태입니다. 우선순위별로 준비 큐를 여러개 사용하는 스케줄링 방식입니다. 우선순위가 가장 높은 큐의 프로세스를 먼저 처리하고 큐가 비워지면 그 다음 순위의 큐의 프로세스를 처리하는 방식입니다. 

다단계 큐 스케줄링도 문제점이 있습니다. 바로 큐 간의 프로세스의 이동이 불가능하다는 점입니다. 이렇기 때문에 결국에는 낮은 우선순위 큐에 있는 프로세스들은 실행되지 못 하는 기아현상이 발생하게 됩니다. 

## 3.7 다단계 피드백 큐 스케줄링

다단계 큐 방식의 발전된 형태입니다. 바로 큐 간의 프로세스 이동이 가능해진 방식입니다. 

예를 들어 우선순위가 1인 큐에 있던 프로세스가 CPU를 사용하다가 CPU 이용 시간이 지나서 도중에 종료가 된다면 이 프로세스는 우선순위가 2인 큐로 삽입됩니다. 이런 방식으로 점점 낮은 순위로 프로세스가 이동됩니다. 이렇게 처리하게 되면 CPU를 자주 쓰는 프로세스의 경우에는 우선순위가 점차 낮아지게 될 것입니다. 반대로 CPU 사용이 적은 입출력 위주의 프로세스는 높은 우선순위 큐에서 모두 종료될 것입니다. 

또한 다단계 큐 스케줄링 방식에서 문제점으로 거론된 기아 현상도 해결할 수 있습니다. 큐 간의 프로세스 이동이 가능해졌기 때문에 우선순위를 올리는 것이 가능해지기 때문입니다.

&nbsp;

# 4. 마치며

CPU 스케줄링은 이번에 공부하면서 처음 들어본 단어입니다. 운영체제가 이렇게 많은 일을 한다는 것이 신기하면서도 운영체제를 만드는 사람은 어떤 사람들일까 하는 막연한 궁금증도 생겼습니다. CPU 스케줄링 알고리즘에서 등장한 라운드 로빈이라는 개념은 CPU 스케줄링 외에도 CS 전반에서 중요하게 등장하는 개념이라고 하니 좀 더 공부를 해보면 좋을 것 같습니다. 