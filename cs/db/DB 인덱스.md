# 1. 들어가며

DB에서 인덱스(Index) 는 자주 등장하는 개념이며 중요성 또한 높습니다. 성능과 유의미한 관련이 많기 때문입니다. 이번 글에서는 DB 인덱스의 개념에 대해서 정리해보고자 합니다.

&nbsp;

# 2. Index를 사용하는 이유

인덱스를 사용하는 이유는 **조건을 만족하는 데이터를 더 빠르게 조회**하기 위함입니다. 인덱스를 사용하지 않았을 경우에는 DB에 저장된 전체 데이터를 스캔하며 조건을 충족하는 데이터를 조회해야 하기 때문에 시간복잡도가 O(N) 입니다. 그러나 인덱스를 사용하게 되면 시간복잡도를 O(logN) 으로 조회를 마칠 수 있습니다. 뿐만 아니라 **데이터를 빠르게 정렬하거나 그룹핑**할 때에도 인덱스는 유용하게 사용할 수 있습니다.

&nbsp;

# 3. B-Tree 기반 Index 동작 방식

**[Members]** 

|  a   |  b   |  c   |
| :--: | :--: | :--: |
|  3   | ...  | ...  |
|  7   | ...  | ...  |
|  1   | ...  | ...  |
|  2   | ...  | ...  |
|  9   | ...  | ...  |
|  7   | ...  | ...  |
|  13  | ...  | ...  |
|  5   | ...  | ...  |
|  7   | ...  | ...  |
|  2   | ...  | ...  |

이런 테이블이 있다고 할 때 a column에 인덱스를 걸면 다음과 같이 됩니다.

<br>

**[Index a]**

|  a   | ptr  |
| :--: | :--: |
|  1   | ...  |
|  2   | ...  |
|  2   | ...  |
|  3   | ...  |
|  5   | ...  |
|  7   | ...  |
|  7   | ...  |
|  7   | ...  |
|  9   | ...  |
|  13  | ...  |

인덱스의 특징을 간단히 짚어보겠습니다.

- a의 값이 오름차순으로 정렬이 된다.
- 포인터라는 데이터를 가지고 있다. 포인터는 실제 Members 테이블의 각 데이터를 가리킨다.

이런 상황에서 `where a = 9` 라는 조건을 가지고 있는 쿼리를 실행해본다고 해보겠습니다. 

> 1. 인덱스 테이블에서 a의 값을 조회한다. 
>    - 이 때 인덱스 테이블에 있는 a의 값을 순차적으로 모두 조회하는 것이 아니라 Binary Search를 한다. 
> 2. 값을 찾으면 포인터를 통해 실제 테이블에 있는 값에 도달한다.
> 3. 인덱스 테이블에 a = 9 를 만족하는 경우가 또 있는지 확인한다. (처음 찾은 지점 위 • 아래 모두 조회 → Binary Search 이기 때문)
> 4. 없으면 종료한다.

<br>

그런데 만약 `where a = 7 and b = 95` 이렇게 두 가지 값이 조건에 있다면 어떻게 될까요? 현재 인덱스 테이블에는 a 만 있는 상황인데 찾아야 하는 조건은 두 개인 상황이 된 것입니다.

> 1. 인덱스 테이블에서 a의 값을 조회한다. 
>    - 이 때 인덱스 테이블에 있는 a의 값을 순차적으로 모두 조회하는 것이 아니라 Binary Search를 한다.
> 2. 값을 찾으면 포인터를 통해 실제 테이블에 있는 값에 도달한다.
> 3. 그리고 나서 b = 95 인 값을 스캔해서 조회한다.
> 4. 인덱스 테이블에 a = 7 을 만족하는 경우가 또 있는지 확인한다.  (처음 찾은 지점 위 • 아래 모두 조회 → Binary Search 이기 때문)
>    - 다면 2번과 3번 작업 반복
> 5. 없으면 종료한다.

두번째 케이스는 a = 7 인 경우가 3개 있습니다. 그렇다면 일단 Members 테이블을 3번 조회하게 될 것이고 b는 인덱스가 없기 때문에 b = 95 조건을 만족하는 데이터를 찾기 위해 Members 테이블을 Full-Scan을 3번 해야만 합니다. 이것은 효율적이지 못 한 상황입니다. 이런 문제를 해결하기 위한 가장 좋은 방법은 a와 b 모두에 인덱스를 만들어 주는 것입니다. 

<br>

**[Members]** 

|  a   |  b   |  c   |
| :--: | :--: | :--: |
|  3   | 100  | ...  |
|  7   |  78  | ...  |
|  1   |  92  | ...  |
|  2   |  93  | ...  |
|  9   |  80  | ...  |
|  7   |  95  | ...  |
|  13  | 100  | ...  |
|  5   |  81  | ...  |
|  7   |  80  | ...  |
|  2   |  92  | ...  |

**[Index a, b]**

|  a   |  b   | ptr  |
| :--: | :--: | :--: |
|  1   |  92  | ...  |
|  2   |  92  | ...  |
|  2   |  93  | ...  |
|  3   | 100  | ...  |
|  5   |  81  | ...  |
|  7   |  78  | ...  |
|  7   |  80  | ...  |
|  7   |  95  | ...  |
|  9   |  80  | ...  |
|  13  | 100  | ...  |

<br>

예시에 있는 데이터를 기반으로 복합 인덱스를 만들면 다음과 같은 모습이 됩니다. 복합 인덱스를 만들 때 가장 중요한 것은 **어떤 기준으로 정렬이 되는가?** 인데요. 일반적인 경우에는 인덱스 왼쪽에 있는 값을 기준으로 정렬이 됩니다. 지금 예시에서는 Index(a, b) 이기 때문에 a를 기준으로 정렬이 된 것을 확인할 수 있습니다. 따라서 인덱스를 만들 때는 순서도 중요하다는 것을 확인할 수 있습니다.

그런데 한 가지 주의할 점이 있습니다. 만약 이 경우에 `where b = 95` 라는 조건이 있는 쿼리를 실행시키면 어떻게 될까요? 이 경우에는 인덱스를 활용하지 않습니다. 왜냐하면 현재 Index(a, b) 는 a를 기준으로 정렬이 돼 있기 때문에 b = 95 라는 조건을 만족하는 b 값을 찾으려면 결국 인덱스에서도 Full-Scan을 해야되기 때문입니다. 그래서 이런 경우에는 인덱스를 활용하지 않거나 혹은 b 인덱스를 별도로 만들어 주는 것이 좋습니다.

&nbsp;

# 4. 그렇다면 인덱스를 많이 만들수록 좋은 것인가?

인덱스의 효과를 경험하고 나면 인덱스를 많이 만들고 싶은 욕구가 생길 수 있습니다. 그러나 개발은 늘 Trade-Off 가 있다는 것을 기억해야만 합니다. 인덱스를 만들면 **별도의 인덱스 테이블이 생기면서** 그 곳에는 포인터라는 **기존 테이블에는 없던 새로운 유형의 데이터가 쌓이게 됩니다**. 

이것을 고려해서 인덱스를 만들 때 주의할 점이 있습니다. 

1. 기존 테이블에 write (삽입, 수정, 삭제) 작업을 할 때마다 인덱스 테이블도 변경이 일어나게 됩니다.

   → 인덱스가 많아질수록 기존 테이블에 write 작업을 할 때마다 오버헤드가 발생할 수 있습니다.

2. 추가적인 저장 공간이 필요합니다.

   → 인덱스마다 새로운 유형의 데이터가 쌓이기 때문입니다.

따라서 불필요한 인덱스를 무작정 만드는 것은 오히려 성능에 저하가 생길 수 있고 DB 운영 비용만 늘어날 수도 있는 것입니다.

&nbsp;

# 5. 마치며

DB에서 인덱스는 상당히 중요한 개념입니다. 특히 중간에 언급한 B-Tree 기반의 작동원리까지 제대로 이해하고 아는 것이 중요한 것 같습니다. 추후 B-Tree 기반 인덱스의 작동원리까지 정리해보도록 하겠습니다.