# 1. 들어가며

여러 트랜잭션들이 동시에 실행되는 과정에서 발생할 수 있는 동시성 문제를 여러 번에 걸쳐서 공부하는 시리즈의 첫번째 정리 글입니다. 데이터베이스 이론에서 트랜잭션의 이론은 정말 중요할 뿐 아니라 동시성 문제(OS 차원, DB 차원 모두 다!) 역시 실제 개발 과정에서 중요한 문제이므로 잘 정리해보도록 하겠습니다.

모든 내용은 [쉬운 코드 - 데이터베이스 입문](https://youtube.com/playlist?list=PLcXyemr8ZeoREWGhhZi5FZs6cvymjIBVe&si=kypiGMqy_7iu3yX-) 강좌를 참고해서 작성했습니다.

&nbsp;

# 2. 예제 

데이터베이스의 스케줄 개념을 살펴 보기 앞서 간단한 예제를 먼저 세팅해보겠습니다.

> A가 B에게 20만원을 이체하려고 한다. 이 때 B도 ATM에서 본인 계좌에 30만원을 입금한다면 여러 형태의 실행이 가능할 수 있다.
>
> A 계좌 잔액 100만원, B 계좌 잔액 200만원 

⚠️참고: r(), w() 은 DB Read, Write 작업의 줄임말이고 괄호 안에 들어가는 것은 어느 데이터에 접근할 지를 의미하는 것입니다.

(편의상 트랜잭션1은 볼드 처리, 트랜잭션2는 일반 굵기로 표현하겠습니다.)

- Case 1

  **r(A)**: 100만원 → **w(A)**: 80만원 → **r(B)**: 200만원 → **w(B)**: 220만원 → T1 커밋 → r(B): 220만원 → w(B): 250만원 → T2 커밋

  결과: B 계좌 잔액 250만원

- Case 2

  r(B): 200만원 → w(B): 230만원 → T2 커밋 → **r(A)**: 100만원 → **w(A)**: 80만원 → **r(B)**: 230만원 → **w(B)**: 250만원 → T1 커밋

  결과: B 계좌 잔액 250만원

- Case 3

  **r(A)**: 100만원 → **w(A)**: 80만원 → r(B): 200만원 → w(B): 230만원 → T2 커밋 → **r(B)**: 230만원 → **w(B)**: 250만원 → T1 커밋 

  결과: B 계좌 잔액 250만원

- Case 4

  **r(A)**: 100만원 → **w(A)**: 80만원 → **r(B)**: 200만원 → r(B): 200만원 → w(B): 230만원 → T2 커밋 → **w(B)**: 220만원 → T1 커밋

  결과: B 계좌 잔액 220만원 🔥 30만원 어디로??

<br>



이렇게 여러 트랜잭션이 동시에 작업에 참여할 때, Read 시점에 따라 데이터가 의도하지 않은 대로 조회됨에 따라 최종적으로 데이터가 이상하게 꼬여버리는 현상을 **Lost Update** 라고 합니다. 

&nbsp;

# 3. 스케줄(Schedule)

스케줄은 오퍼레이션(Operation)의 집합입니다.

> 오퍼레이션(Operation): 각 트랜잭션 안에서 실행되는 개별 작업들 → SQL에 의해서 실행되는 것이라고 이해하면 될 것 같습니다. 

<br>

스케줄은 또 다시 종류를 구분을 할 수 있습니다.

- 시리얼 스케줄(Serial Schedule)
  - 각 트랜잭션이 겹치지 않고 하나씩 실행되는 스케줄(Case 1, 2)
  - 트랜잭션 내의 read, write 작업과 같이 I/O 작업이 있을 때 한 번에 하나의 트랜잭션만 실행되기 때문에 CPU는 하나의 트랜잭션에 I/O 작업이 있을 때 놀게 된다. => 성능 상 좋지 않기 때문에 현실적으로 잘 쓰지 않는 방법
- 논 시리얼 스케줄(None Serial Schedule)
  - 각 트랜잭션이 겹쳐서 실행되는 스케줄(Case 3, 4)
  - 트랜잭션이 겹쳐서 실행되기 때문에 같은 시간 동안 더 많은 트랜잭션을 처리할 수 있다는 성능 상 이점이 있다.
  - 다만 트랜잭션이 겹쳐서 실행되는 과정에서 결과가 이상해지는 문제가 발생할 수 있다.(Case 4)

&nbsp;

# 4. 직렬 가능성(Serialibility)

직렬 가능성에 대해서 알아보기 전에 왜 이것을 고민하게 됐는지를 먼저 간단하게 언급하고 넘어가고자 합니다. 

사실 이유는 명확합니다. 논 시리얼 스케줄이 성능 상 유리하기 때문에 논 시리얼 스케줄로 트랜잭션들을 처리하고 싶은데, Lost Update 같은 예기치 못 한 상황이 발생할 수 있기 때문에 개발자들은 논 시리얼 스케줄을 시리얼 스케줄처럼 실행하고 싶었습니다. 다시 말해서 시리얼 스케줄과 동일한 논 시리얼 스케줄을 실행하고 싶었다는 것입니다.

여기서 한 가지 고민이 생기게 됩니다. 그렇다면 스케줄이 동일하다는 것을 어떻게 정의할 것인가? 에 대한 고민이 생긴 것이죠. 이하에서 정리할 내용은 스케줄의 동등성을 정의하기 위한 개념들과 데이터베이스 동시성에서 중요한 개념인 직렬 가능성에 대해서 정리해보겠습니다.

&nbsp;

## 4.1 충돌(Conflict)

충돌은 두 개 이상의 오퍼레이션들에 대해서 적용되는 개념입니다. 다음 세 가지 조건을 모두 만족하면 충돌이라고 합니다.

1. 서로 다른 트랜잭션 소속
2. 같은 데이터에 접근
3. 최소 하나는 Write Operation일 것

예를 들어서 Case3를 한 번 보도록 하겠습니다. 

- T2r(B) 와 T1w(B)
- T2w(B) 와 T1r(B)
- T2w(B) 와 T1w(B)

<br>

그렇다면 충돌이라는 개념은 왜 중요한 것일까요? 바로 충돌하는 오퍼레이션들끼리는 **순서가 변경되면 결과도 달라지기 때문**입니다. 예를 들어 보겠습니다. 현재 Case 3에서 T2w(B): B 230만원, T1r(B): 230만원의 결과를 볼 수 있습니다. 그런데 만약 T1r(B)가 먼저 실행된다면 230만원을 읽는 것이 아니라 200만원을 읽게 됩니다. 

충돌의 이런 성질은 충돌 동등성이라는 것을 정의할 수 있게 해줍니다.

&nbsp;

## 4.2 충돌 동등성(Conflict Equivalent)

충돌 동등성이란 두 개의 스케줄이 다음 두 가지 조건을 모두 만족하는 것을 의미합니다.

1. 두 스케줄은 같은 트랜잭션들을 가진다.
2. 어떤 컨플릭팅 오퍼레이션의 순서도 양쪽 스케줄 모두 동일하다.

<br>



Case2와 Case3을 예로 들어보겠습니다. 

- 1번 조건: 둘 다 T1, T2 가지고 있으므로 조건 충족
- 2번 조건: 충족
  - Case 3에서 T2r(B) → T1w(B) 와 Case 2에서 T2r(B) → T1w(B) 
  - Case 3에서 T2w(B) → T1r(B) 와 Case 2에서 T2w(B) → T1r(B)
  - Case 3에서 T2w(B) → T1w(B) 와 Case 2에서 T2w(B) → T1w(B)

따라서 Case2 와 Case3은 충돌 동등하다고 할 수 있습니다. 그런데 Case2는 시리얼 스케줄이고 Case3는 논 시리얼 스케줄입니다. 

<br>

이처럼 **논 시리얼 스케줄이 시리얼 스케줄과 충돌 동등할 때를 충돌 직렬화 가능(Conflict Serializable)하다**고 표현합니다. 그리고 이런 충돌 직렬화 가능한 논 시리얼 스케줄은 실행해도 시리얼 스케줄과 같은 결과를 얻어낼 수 있기 때문에 걱정 없이 실행해도 되는 것입니다.

<br>

그렇다면 Case4는 충돌 직렬화 가능성이 있을까요? 확인해보겠습니다.

- Case 2와 비교

  	- 1번 조건: 충족 Ok

   - 2번 조건: 충족 Fail
     - Case4에서 T1r(B) → T2w(b) vs Case2에서 T2w(b) → T1r(B) 🔥순서가 다르다!

- Case1과 비교

  - 1번 조건: 충족 Ok
  - 2번 조건: 충족 Fail
    - Case4에서 T2r(B) → T1w(B) vs Case1에서 T1w(B) → T2r(B) 🔥순서가 다르다!

&nbsp;

결론적으로 논 시리얼 스케줄로 DB 작업을 처리하고 싶지만 Lost Update 와 같은 예기치 못 한 결과를 방지하기 위해 시리얼 스케줄처럼 실행하기 위해서는 충돌 오퍼레이션의 순서가 중요합니다. 충돌 오퍼레이션의 순서에 따라서 충돌 동등성의 여부가 결정되기 때문입니다. 

그러면 이렇게 충돌 동등한 지를 어떻게 판단을 할 수 있을까요? 보통 RDBMS에서는 여러 트랜잭션들이 동시에 실행되도 스케줄이 Conflict Serializable하도록 보장하는 프로토콜을 적용하는 방식으로 보장해주고 있습니다. 

그리고 동시성 제어(Concurrency Control)는 이러한 트랜잭션들을 직렬 가능(Serializable)하게 만들어주는 작업을 의미합니다. 그리고 이런 동시성 제어에서 가장 중요한 개념이 **트랜잭션 격리수준(Isolation)**입니다. 이것에 대해서는 다른 글에서 정리해보도록 하겠습니다. 